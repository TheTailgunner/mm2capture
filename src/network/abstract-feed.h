/* By Vladislav Nikolaev nvladislav9 at gmail dot com

This file is part of mm2capture.

mm2capture is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

mm2capture is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details. */

/*! \file Message input stream implementation
 */
#ifndef _ABSTRACT_FEED_H
#define _ABSTRACT_FEED_H

#include <QSharedPointer>
#include <QVector>
#include <modes/modes-data.h>
#include "feed-counter.h"

namespace MM2Capture {
class ModesDecoder;
/*!
 * \brief Abstract message input stream.
 */
class AbstractInputFeed {
public:
  using Ptr = QSharedPointer<AbstractInputFeed>;
  AbstractInputFeed();
  //! Puts stream into the running state.
  virtual void start() = 0;
  //! Terminates stream.
  virtual void stop() = 0;
  virtual ~AbstractInputFeed() {}
  //! Returns autogenerated input's ID.
  const QString &id() const { return m_strId; }
  //! Returns feed stats accumulator (see FeedCounter)
  const FeedCounter &stats() const { return m_stats; }
  /*!
   * \brief Indicates some data was read and parsed.
   * \details Indicates if some messages was produced during the last
   * data fetch attempt
   * \returns true if messages fetched; otherwise false
   */
  virtual operator bool() const { return false; }
  /*! \brief Fetches bytes and tries to parse it.
   *  \param [out] out - resulting messages would pe pushed here
   */
  virtual AbstractInputFeed &operator>>(QVector<ModesData> &out) = 0;

protected:
  QSharedPointer<ModesDecoder> m_pDecoder;
  QString m_strId;
  FeedCounter m_stats;
};

class AbstractOutputFeed {
public:
  using Ptr = QSharedPointer<AbstractOutputFeed>;

  AbstractOutputFeed();
  virtual ~AbstractOutputFeed() {}

  virtual void start() = 0;
  virtual void stop() = 0;

  void setOutputType(ModesData::MessageType t) { m_outputType = t; }

  const FeedCounter &stats() const { return m_stats; }

  virtual AbstractOutputFeed &operator<<(const ModesData &) = 0;

protected:
  FeedCounter m_stats;
  ModesData::MessageType m_outputType;
};
}
#endif
